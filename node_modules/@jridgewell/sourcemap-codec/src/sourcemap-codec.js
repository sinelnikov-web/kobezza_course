"use strict";
exports.__esModule = true;
exports.encode = exports.decode = void 0;
var comma = ','.charCodeAt(0);
var semicolon = ';'.charCodeAt(0);
var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
var intToChar = new Uint8Array(64); // 64 possible chars.
var charToInt = new Uint8Array(128); // z is 122 in ASCII
for (var i = 0; i < chars.length; i++) {
    var c = chars.charCodeAt(i);
    intToChar[i] = c;
    charToInt[c] = i;
}
// Provide a fallback for older environments.
var td = typeof TextDecoder !== 'undefined'
    ? /* #__PURE__ */ new TextDecoder()
    : typeof Buffer !== 'undefined'
        ? {
            decode: function (buf) {
                var out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
                return out.toString();
            }
        }
        : {
            decode: function (buf) {
                var out = '';
                for (var i = 0; i < buf.length; i++) {
                    out += String.fromCharCode(buf[i]);
                }
                return out;
            }
        };
function decode(mappings) {
    var state = new Int32Array(5);
    var decoded = [];
    var index = 0;
    do {
        var semi = indexOf(mappings, index);
        var line = [];
        var sorted = true;
        var lastCol = 0;
        state[0] = 0;
        for (var i = index; i < semi; i++) {
            var seg = void 0;
            i = decodeInteger(mappings, i, state, 0); // genColumn
            var col = state[0];
            if (col < lastCol)
                sorted = false;
            lastCol = col;
            if (hasMoreVlq(mappings, i, semi)) {
                i = decodeInteger(mappings, i, state, 1); // sourcesIndex
                i = decodeInteger(mappings, i, state, 2); // sourceLine
                i = decodeInteger(mappings, i, state, 3); // sourceColumn
                if (hasMoreVlq(mappings, i, semi)) {
                    i = decodeInteger(mappings, i, state, 4); // namesIndex
                    seg = [col, state[1], state[2], state[3], state[4]];
                }
                else {
                    seg = [col, state[1], state[2], state[3]];
                }
            }
            else {
                seg = [col];
            }
            line.push(seg);
        }
        if (!sorted)
            sort(line);
        decoded.push(line);
        index = semi + 1;
    } while (index <= mappings.length);
    return decoded;
}
exports.decode = decode;
function indexOf(mappings, index) {
    var idx = mappings.indexOf(';', index);
    return idx === -1 ? mappings.length : idx;
}
function decodeInteger(mappings, pos, state, j) {
    var value = 0;
    var shift = 0;
    var integer = 0;
    do {
        var c = mappings.charCodeAt(pos++);
        integer = charToInt[c];
        value |= (integer & 31) << shift;
        shift += 5;
    } while (integer & 32);
    var shouldNegate = value & 1;
    value >>>= 1;
    if (shouldNegate) {
        value = -0x80000000 | -value;
    }
    state[j] += value;
    return pos;
}
function hasMoreVlq(mappings, i, length) {
    if (i >= length)
        return false;
    return mappings.charCodeAt(i) !== comma;
}
function sort(line) {
    line.sort(sortComparator);
}
function sortComparator(a, b) {
    return a[0] - b[0];
}
function encode(decoded) {
    var state = new Int32Array(5);
    var bufLength = 1024 * 16;
    var subLength = bufLength - 36;
    var buf = new Uint8Array(bufLength);
    var sub = buf.subarray(0, subLength);
    var pos = 0;
    var out = '';
    for (var i = 0; i < decoded.length; i++) {
        var line = decoded[i];
        if (i > 0) {
            if (pos === bufLength) {
                out += td.decode(buf);
                pos = 0;
            }
            buf[pos++] = semicolon;
        }
        if (line.length === 0)
            continue;
        state[0] = 0;
        for (var j = 0; j < line.length; j++) {
            var segment = line[j];
            // We can push up to 5 ints, each int can take at most 7 chars, and we
            // may push a comma.
            if (pos > subLength) {
                out += td.decode(sub);
                buf.copyWithin(0, subLength, pos);
                pos -= subLength;
            }
            if (j > 0)
                buf[pos++] = comma;
            pos = encodeInteger(buf, pos, state, segment, 0); // genColumn
            if (segment.length === 1)
                continue;
            pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex
            pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine
            pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn
            if (segment.length === 4)
                continue;
            pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex
        }
    }
    return out + td.decode(buf.subarray(0, pos));
}
exports.encode = encode;
function encodeInteger(buf, pos, state, segment, j) {
    var next = segment[j];
    var num = next - state[j];
    state[j] = next;
    num = num < 0 ? (-num << 1) | 1 : num << 1;
    do {
        var clamped = num & 31;
        num >>>= 5;
        if (num > 0)
            clamped |= 32;
        buf[pos++] = intToChar[clamped];
    } while (num > 0);
    return pos;
}
